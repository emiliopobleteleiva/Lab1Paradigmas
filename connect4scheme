#lang scheme

;constructores

;player
(define player(lambda(id name color wins losses draws remaining-pieces)
               (list id name color wins losses draws remaining-pieces)
  ))
;piezas
(define piece(lambda(color)
               (list color)
               )
  )
;board

(define (board)
  (make-list 7 (make-list 6 'empty))
  );lista de 7 listas con 6 elementos cada una // apoyo: gpt codepilot

;modificar board

(define (empty-board board)
                     (define (empty-column column) ;modificar una lista dada, de forma que todos sus elementos serán cambiados por 0
                                           (map (lambda (x) 0) column))
                     (map empty-column board)) ;ejecutar (map funcion board), de esta manera se ejecuta "empty-column" en cada columna del tablero
;//apoyo: gpt codepilot

;board / otros

;board board-can-play?

(define board-can-play?(lambda(board) ;return bool #t o #f
                         (cond ((null? board) #f) ;comprobar si la lista actual es nula
                               ((member 0 (car board)) #t);comprobar que 0 exista dentro de la sublista, funcion member implementada con apoyo de gpt codepilot
                               (else (board-can-play? (cdr board))) ;caso else, se realiza una recursión eliminando la primera sublista
                               )
                         )
  )

;board set piece (preparaciones)

;debería llegar abajo y subir para ver si este elemento esta disponible, lo voy a hacer primero definiendo funciones similares a car o cdr pero alreves

;funcion anticar, similar a car, pero devuelve el ultimo elemento de la lista
(define anticar (lambda(lista)
                  (if (null? (cdr lista)) (car lista)
                      (anticar (cdr lista))
                      )
                  )
  )

;funcion anticdr, similar a cdr pero alrevez, devuelve toda la lista menos el ultimo elemento
(define anticdr(lambda(lista)
                 (define recursiva(lambda(lista listout)
                                    (if (null? (cdr lista)) listout
                                        (recursiva (cdr lista) (append listout (list (car lista)))) ;error1: le di 5 en lugar de '(5), resolver cambiando el (car lista) por (list (car lista))
                                        ;error2: se está tratando de asignar valor a listout, deberia hacerse esto en la ejecucion de la funcion recursiva
                                        )
                                    )
                   )
                 (recursiva lista '())
                 )
  )

;funcion elementoN(lista n) que devuelva el elemento situadio en la posicion n de la lista

(define elemento(lambda(lista n)
                  (define recursiva(lambda(lista n aux)
                                     (if (= aux n) (car lista)
                                         (recursiva (cdr lista) n (+ aux 1))
                                         )
                                     )
                    )
                  (recursiva lista n 1)
                  )
  )

;funcion de si es ultimo elemento de una lista
(define isLast?(lambda(lista elemento)
                 (if (null? (cdr lista)) 
                     (if(= elemento (car lista)) #t
                        (isLast? (cdr lista) elemento)
                        )
                     (#f)
                     )
                 )
  )
; funcion que reemplaza elemento especifico de una lista por otro
(define replace-with(lambda(lista pos elemento)
                      (define recursiva(lambda(lista pos elemento listout aux)
                                         (if (null? lista) listout ;si se esta en la ultima posicion +1 de la lista, devolver listout
                                             (if (= aux pos) (recursiva (cdr lista) pos elemento (append listout (list elemento)) (+ aux 1))
                                                 (recursiva (cdr lista) pos elemento (append listout (list (car lista))) (+ aux 1))
                                                 )
                                             )
                                         )
                        )
                      (recursiva lista pos elemento '() 1)
                      )
  )

;quizás hacer la misma funcion pero aux = len-1?
(define largo-lista(lambda(lista)
                     (define recursiva(lambda(lista aux)
                                        (if (null? lista) aux
                                            (recursiva (cdr lista) (+ aux 1))
                                            )
                                        )
                       )
                     (recursiva lista 1)
                     )
  )

;definir inverse replace with
(define inverse-replace-with(lambda(lista pos elemento)
                              (replace-with lista (- (largo-lista lista) pos) elemento)
                              )
  )
;definir display-board
(define display-board(lambda(board)
                       (newline)
                       (if (null? (cdr board))
                           (begin (display (car board)) (display "done"))
                           (begin (display (car board)) (display-board (cdr board)))
                           )
                       )
  ) ;apoyo gpt codecopilot / aplicar "begin"

;funcion board-set-play-piece, comprueba si la jugada es posible, y la realiza
(define board-set-play-piece(lambda(board column piece)
                              (define recursiva(lambda(board boardaux column fila fila-actual piece)
                                                 (if (equal? (elemento fila-actual column) 0);abrir if principal / si elemento señalado es 0, entonces
                                                     (inverse-replace-with board fila (replace-with fila-actual column piece));then principal
                                                     (if (null? boardaux);if interno, comprobar si la siguiente fila es nula
                                                         (begin (display "Columna completa, probar con otro valor") board);then / failsafe
                                                         (recursiva board (anticdr boardaux) column (+ fila 1) (anticar boardaux) piece);error1: no se puede poner "anticar" a una lista vacia, da error,
                                                         );else principal 
                                                         );cierre if principal 
                                                       )
                                                 )
                              (recursiva board (anticdr board) column 1 (anticar board) piece)
                              )
  )

;testing
(display "test funciones board")
(define board1 (empty-board (board)))
(newline)
(display "board-set-play-piece test")
(newline)
(define piece1 (piece "red"))
(display-board (board-set-play-piece (board-set-play-piece (board-set-play-piece (board-set-play-piece (board-set-play-piece (board-set-play-piece (board-set-play-piece (board-set-play-piece board1 3 piece1) 3 piece1) 3 piece1) 3 piece1) 3 piece1) 3 piece1) 3 piece1) 3 piece1))

;para nueva funcion definida, funciona hasta que se llega a la penultima linea